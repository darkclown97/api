// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.5.1
//   protoc               v3.12.4
// source: services/ecommerce/v1/orders.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Meta, PageOptions } from "../../../common/messages";
import { Timestamp } from "../../../google/protobuf/timestamp";
import {
  Payment,
  PaymentMethod,
  paymentMethodFromJSON,
  paymentMethodToJSON,
  PaymentStatus,
  paymentStatusFromJSON,
  paymentStatusToJSON,
} from "./payments";
import { Seller } from "./products";

export const protobufPackage = "services.ecommerce.v1.orders";

export enum OrderStatus {
  ORDER_STATUS_CREATED = 0,
  ORDER_STATUS_CANCELED = 1,
  ORDER_STATUS_CONFIRMED = 2,
  ORDER_STATUS_PACKED = 3,
  ORDER_STATUS_SHIPPED = 4,
  ORDER_STATUS_DELIVERED = 5,
  ORDER_STATUS_COMPLETED = 6,
  UNRECOGNIZED = -1,
}

export function orderStatusFromJSON(object: any): OrderStatus {
  switch (object) {
    case 0:
    case "ORDER_STATUS_CREATED":
      return OrderStatus.ORDER_STATUS_CREATED;
    case 1:
    case "ORDER_STATUS_CANCELED":
      return OrderStatus.ORDER_STATUS_CANCELED;
    case 2:
    case "ORDER_STATUS_CONFIRMED":
      return OrderStatus.ORDER_STATUS_CONFIRMED;
    case 3:
    case "ORDER_STATUS_PACKED":
      return OrderStatus.ORDER_STATUS_PACKED;
    case 4:
    case "ORDER_STATUS_SHIPPED":
      return OrderStatus.ORDER_STATUS_SHIPPED;
    case 5:
    case "ORDER_STATUS_DELIVERED":
      return OrderStatus.ORDER_STATUS_DELIVERED;
    case 6:
    case "ORDER_STATUS_COMPLETED":
      return OrderStatus.ORDER_STATUS_COMPLETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrderStatus.UNRECOGNIZED;
  }
}

export function orderStatusToJSON(object: OrderStatus): string {
  switch (object) {
    case OrderStatus.ORDER_STATUS_CREATED:
      return "ORDER_STATUS_CREATED";
    case OrderStatus.ORDER_STATUS_CANCELED:
      return "ORDER_STATUS_CANCELED";
    case OrderStatus.ORDER_STATUS_CONFIRMED:
      return "ORDER_STATUS_CONFIRMED";
    case OrderStatus.ORDER_STATUS_PACKED:
      return "ORDER_STATUS_PACKED";
    case OrderStatus.ORDER_STATUS_SHIPPED:
      return "ORDER_STATUS_SHIPPED";
    case OrderStatus.ORDER_STATUS_DELIVERED:
      return "ORDER_STATUS_DELIVERED";
    case OrderStatus.ORDER_STATUS_COMPLETED:
      return "ORDER_STATUS_COMPLETED";
    case OrderStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface OrderItem {
  /** Product ID */
  productId: string;
  /** Product name */
  name: string;
  /** Quantity of the product */
  quantity: number;
  /** Price per item */
  price: number;
  seller?: Seller | undefined;
}

export interface CreateOrderRequest {
  /** Cart ID for orders with multiple items */
  cartId?:
    | string
    | undefined;
  /** Single item purchase (instant buy) */
  item?:
    | OrderItem
    | undefined;
  /** Address for shipping */
  shippingAddress: string;
  /** Address for billing (if different) */
  billingAddress: string;
  sameAsShippingAddress: boolean;
  /** Payment method - credit card, upi, etc. */
  paymentMethod: PaymentMethod;
}

export interface CreateOrderResponse {
  orderId: string;
  status: OrderStatus;
  /** Payment status - initiated, pending, fulfilled, failed */
  paymentStatus: PaymentStatus;
}

export interface ListOrdersRequest {
  pageOptions?: PageOptions | undefined;
  searchTerm: string;
}

export interface ListOrdersResponse {
  /** List of orders */
  orders: Order[];
  /** Total number of orders matching the criteria */
  totalOrders: number;
}

export interface Order {
  /** Unique identifier for the order */
  orderId: string;
  /** List of items in the order */
  items: OrderItem[];
  /** Shipping address for the order */
  shippingAddress: string;
  /** Billing address for the order */
  billingAddress: string;
  /** Flag indicating if billing address is the same as shipping address */
  sameAsShippingAddress: boolean;
  /** Order status (e.g., pending, shipped, completed) */
  status: OrderStatus;
  /** Total price of the order */
  totalPrice: number;
  /** Payment method (e.g., credit card, upi, etc.) */
  paymentMethod: PaymentMethod;
  /** Payment status (e.g., successful, failed) */
  paymentStatus: PaymentStatus;
  /** Timestamp when the order was created */
  createdAt?:
    | Date
    | undefined;
  /** Timestamp when the order was delivered */
  deliveredAt?: Date | undefined;
}

export interface GetOrdersRequest {
  orderId: string;
}

export interface GetOrdersResponse {
  detail?: Order | undefined;
}

export interface UpdateOrderPaymentRequest {
  orderId: string;
  paymentId: string;
  paymentStatus: PaymentStatus;
}

export interface UpdateOrderPaymentResponse {
}

export interface CancelOrderRequest {
  orderId: string;
}

export interface CancelOrderResponse {
}

/** Only for internal use */
export interface OrderInternal {
  meta?:
    | Meta
    | undefined;
  /** Buyer reference (user ID) */
  buyerId: string;
  /** List of items in the order */
  items: OrderItem[];
  /** Shipping address for the order */
  shippingAddress: string;
  /** Billing address for the order */
  billingAddress: string;
  /** Flag indicating if billing address is the same as shipping address */
  sameAsShippingAddress: boolean;
  /** Total price of the order */
  totalPrice: number;
  /** Order status (e.g., 'pending', 'shipped', 'delivered') */
  orderStatus: OrderStatus;
  /** List of payment attempts */
  payment: Payment[];
  /** Timestamp when the order was delivered */
  deliveredAt?: Date | undefined;
}

function createBaseOrderItem(): OrderItem {
  return { productId: "", name: "", quantity: 0, price: 0, seller: undefined };
}

export const OrderItem: MessageFns<OrderItem> = {
  encode(message: OrderItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.quantity !== 0) {
      writer.uint32(24).int32(message.quantity);
    }
    if (message.price !== 0) {
      writer.uint32(33).double(message.price);
    }
    if (message.seller !== undefined) {
      Seller.encode(message.seller, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.price = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.seller = Seller.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderItem {
    return {
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      seller: isSet(object.seller) ? Seller.fromJSON(object.seller) : undefined,
    };
  },

  toJSON(message: OrderItem): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.seller !== undefined) {
      obj.seller = Seller.toJSON(message.seller);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderItem>, I>>(base?: I): OrderItem {
    return OrderItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderItem>, I>>(object: I): OrderItem {
    const message = createBaseOrderItem();
    message.productId = object.productId ?? "";
    message.name = object.name ?? "";
    message.quantity = object.quantity ?? 0;
    message.price = object.price ?? 0;
    message.seller = (object.seller !== undefined && object.seller !== null)
      ? Seller.fromPartial(object.seller)
      : undefined;
    return message;
  },
};

function createBaseCreateOrderRequest(): CreateOrderRequest {
  return {
    cartId: undefined,
    item: undefined,
    shippingAddress: "",
    billingAddress: "",
    sameAsShippingAddress: false,
    paymentMethod: 0,
  };
}

export const CreateOrderRequest: MessageFns<CreateOrderRequest> = {
  encode(message: CreateOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cartId !== undefined) {
      writer.uint32(10).string(message.cartId);
    }
    if (message.item !== undefined) {
      OrderItem.encode(message.item, writer.uint32(18).fork()).join();
    }
    if (message.shippingAddress !== "") {
      writer.uint32(26).string(message.shippingAddress);
    }
    if (message.billingAddress !== "") {
      writer.uint32(34).string(message.billingAddress);
    }
    if (message.sameAsShippingAddress !== false) {
      writer.uint32(40).bool(message.sameAsShippingAddress);
    }
    if (message.paymentMethod !== 0) {
      writer.uint32(48).int32(message.paymentMethod);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cartId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.item = OrderItem.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.shippingAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.billingAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.sameAsShippingAddress = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.paymentMethod = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOrderRequest {
    return {
      cartId: isSet(object.cartId) ? globalThis.String(object.cartId) : undefined,
      item: isSet(object.item) ? OrderItem.fromJSON(object.item) : undefined,
      shippingAddress: isSet(object.shippingAddress) ? globalThis.String(object.shippingAddress) : "",
      billingAddress: isSet(object.billingAddress) ? globalThis.String(object.billingAddress) : "",
      sameAsShippingAddress: isSet(object.sameAsShippingAddress)
        ? globalThis.Boolean(object.sameAsShippingAddress)
        : false,
      paymentMethod: isSet(object.paymentMethod) ? paymentMethodFromJSON(object.paymentMethod) : 0,
    };
  },

  toJSON(message: CreateOrderRequest): unknown {
    const obj: any = {};
    if (message.cartId !== undefined) {
      obj.cartId = message.cartId;
    }
    if (message.item !== undefined) {
      obj.item = OrderItem.toJSON(message.item);
    }
    if (message.shippingAddress !== "") {
      obj.shippingAddress = message.shippingAddress;
    }
    if (message.billingAddress !== "") {
      obj.billingAddress = message.billingAddress;
    }
    if (message.sameAsShippingAddress !== false) {
      obj.sameAsShippingAddress = message.sameAsShippingAddress;
    }
    if (message.paymentMethod !== 0) {
      obj.paymentMethod = paymentMethodToJSON(message.paymentMethod);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateOrderRequest>, I>>(base?: I): CreateOrderRequest {
    return CreateOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateOrderRequest>, I>>(object: I): CreateOrderRequest {
    const message = createBaseCreateOrderRequest();
    message.cartId = object.cartId ?? undefined;
    message.item = (object.item !== undefined && object.item !== null) ? OrderItem.fromPartial(object.item) : undefined;
    message.shippingAddress = object.shippingAddress ?? "";
    message.billingAddress = object.billingAddress ?? "";
    message.sameAsShippingAddress = object.sameAsShippingAddress ?? false;
    message.paymentMethod = object.paymentMethod ?? 0;
    return message;
  },
};

function createBaseCreateOrderResponse(): CreateOrderResponse {
  return { orderId: "", status: 0, paymentStatus: 0 };
}

export const CreateOrderResponse: MessageFns<CreateOrderResponse> = {
  encode(message: CreateOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.paymentStatus !== 0) {
      writer.uint32(24).int32(message.paymentStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.paymentStatus = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOrderResponse {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      status: isSet(object.status) ? orderStatusFromJSON(object.status) : 0,
      paymentStatus: isSet(object.paymentStatus) ? paymentStatusFromJSON(object.paymentStatus) : 0,
    };
  },

  toJSON(message: CreateOrderResponse): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.status !== 0) {
      obj.status = orderStatusToJSON(message.status);
    }
    if (message.paymentStatus !== 0) {
      obj.paymentStatus = paymentStatusToJSON(message.paymentStatus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateOrderResponse>, I>>(base?: I): CreateOrderResponse {
    return CreateOrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateOrderResponse>, I>>(object: I): CreateOrderResponse {
    const message = createBaseCreateOrderResponse();
    message.orderId = object.orderId ?? "";
    message.status = object.status ?? 0;
    message.paymentStatus = object.paymentStatus ?? 0;
    return message;
  },
};

function createBaseListOrdersRequest(): ListOrdersRequest {
  return { pageOptions: undefined, searchTerm: "" };
}

export const ListOrdersRequest: MessageFns<ListOrdersRequest> = {
  encode(message: ListOrdersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageOptions !== undefined) {
      PageOptions.encode(message.pageOptions, writer.uint32(10).fork()).join();
    }
    if (message.searchTerm !== "") {
      writer.uint32(18).string(message.searchTerm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOrdersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pageOptions = PageOptions.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.searchTerm = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOrdersRequest {
    return {
      pageOptions: isSet(object.pageOptions) ? PageOptions.fromJSON(object.pageOptions) : undefined,
      searchTerm: isSet(object.searchTerm) ? globalThis.String(object.searchTerm) : "",
    };
  },

  toJSON(message: ListOrdersRequest): unknown {
    const obj: any = {};
    if (message.pageOptions !== undefined) {
      obj.pageOptions = PageOptions.toJSON(message.pageOptions);
    }
    if (message.searchTerm !== "") {
      obj.searchTerm = message.searchTerm;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListOrdersRequest>, I>>(base?: I): ListOrdersRequest {
    return ListOrdersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListOrdersRequest>, I>>(object: I): ListOrdersRequest {
    const message = createBaseListOrdersRequest();
    message.pageOptions = (object.pageOptions !== undefined && object.pageOptions !== null)
      ? PageOptions.fromPartial(object.pageOptions)
      : undefined;
    message.searchTerm = object.searchTerm ?? "";
    return message;
  },
};

function createBaseListOrdersResponse(): ListOrdersResponse {
  return { orders: [], totalOrders: 0 };
}

export const ListOrdersResponse: MessageFns<ListOrdersResponse> = {
  encode(message: ListOrdersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.orders) {
      Order.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalOrders !== 0) {
      writer.uint32(16).int32(message.totalOrders);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOrdersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orders.push(Order.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalOrders = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOrdersResponse {
    return {
      orders: globalThis.Array.isArray(object?.orders) ? object.orders.map((e: any) => Order.fromJSON(e)) : [],
      totalOrders: isSet(object.totalOrders) ? globalThis.Number(object.totalOrders) : 0,
    };
  },

  toJSON(message: ListOrdersResponse): unknown {
    const obj: any = {};
    if (message.orders?.length) {
      obj.orders = message.orders.map((e) => Order.toJSON(e));
    }
    if (message.totalOrders !== 0) {
      obj.totalOrders = Math.round(message.totalOrders);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListOrdersResponse>, I>>(base?: I): ListOrdersResponse {
    return ListOrdersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListOrdersResponse>, I>>(object: I): ListOrdersResponse {
    const message = createBaseListOrdersResponse();
    message.orders = object.orders?.map((e) => Order.fromPartial(e)) || [];
    message.totalOrders = object.totalOrders ?? 0;
    return message;
  },
};

function createBaseOrder(): Order {
  return {
    orderId: "",
    items: [],
    shippingAddress: "",
    billingAddress: "",
    sameAsShippingAddress: false,
    status: 0,
    totalPrice: 0,
    paymentMethod: 0,
    paymentStatus: 0,
    createdAt: undefined,
    deliveredAt: undefined,
  };
}

export const Order: MessageFns<Order> = {
  encode(message: Order, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    for (const v of message.items) {
      OrderItem.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.shippingAddress !== "") {
      writer.uint32(26).string(message.shippingAddress);
    }
    if (message.billingAddress !== "") {
      writer.uint32(34).string(message.billingAddress);
    }
    if (message.sameAsShippingAddress !== false) {
      writer.uint32(40).bool(message.sameAsShippingAddress);
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    if (message.totalPrice !== 0) {
      writer.uint32(56).int32(message.totalPrice);
    }
    if (message.paymentMethod !== 0) {
      writer.uint32(64).int32(message.paymentMethod);
    }
    if (message.paymentStatus !== 0) {
      writer.uint32(72).int32(message.paymentStatus);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(82).fork()).join();
    }
    if (message.deliveredAt !== undefined) {
      Timestamp.encode(toTimestamp(message.deliveredAt), writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Order {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.items.push(OrderItem.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.shippingAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.billingAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.sameAsShippingAddress = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.totalPrice = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.paymentMethod = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.paymentStatus = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.deliveredAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Order {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => OrderItem.fromJSON(e)) : [],
      shippingAddress: isSet(object.shippingAddress) ? globalThis.String(object.shippingAddress) : "",
      billingAddress: isSet(object.billingAddress) ? globalThis.String(object.billingAddress) : "",
      sameAsShippingAddress: isSet(object.sameAsShippingAddress)
        ? globalThis.Boolean(object.sameAsShippingAddress)
        : false,
      status: isSet(object.status) ? orderStatusFromJSON(object.status) : 0,
      totalPrice: isSet(object.totalPrice) ? globalThis.Number(object.totalPrice) : 0,
      paymentMethod: isSet(object.paymentMethod) ? paymentMethodFromJSON(object.paymentMethod) : 0,
      paymentStatus: isSet(object.paymentStatus) ? paymentStatusFromJSON(object.paymentStatus) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      deliveredAt: isSet(object.deliveredAt) ? fromJsonTimestamp(object.deliveredAt) : undefined,
    };
  },

  toJSON(message: Order): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => OrderItem.toJSON(e));
    }
    if (message.shippingAddress !== "") {
      obj.shippingAddress = message.shippingAddress;
    }
    if (message.billingAddress !== "") {
      obj.billingAddress = message.billingAddress;
    }
    if (message.sameAsShippingAddress !== false) {
      obj.sameAsShippingAddress = message.sameAsShippingAddress;
    }
    if (message.status !== 0) {
      obj.status = orderStatusToJSON(message.status);
    }
    if (message.totalPrice !== 0) {
      obj.totalPrice = Math.round(message.totalPrice);
    }
    if (message.paymentMethod !== 0) {
      obj.paymentMethod = paymentMethodToJSON(message.paymentMethod);
    }
    if (message.paymentStatus !== 0) {
      obj.paymentStatus = paymentStatusToJSON(message.paymentStatus);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.deliveredAt !== undefined) {
      obj.deliveredAt = message.deliveredAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Order>, I>>(base?: I): Order {
    return Order.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Order>, I>>(object: I): Order {
    const message = createBaseOrder();
    message.orderId = object.orderId ?? "";
    message.items = object.items?.map((e) => OrderItem.fromPartial(e)) || [];
    message.shippingAddress = object.shippingAddress ?? "";
    message.billingAddress = object.billingAddress ?? "";
    message.sameAsShippingAddress = object.sameAsShippingAddress ?? false;
    message.status = object.status ?? 0;
    message.totalPrice = object.totalPrice ?? 0;
    message.paymentMethod = object.paymentMethod ?? 0;
    message.paymentStatus = object.paymentStatus ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.deliveredAt = object.deliveredAt ?? undefined;
    return message;
  },
};

function createBaseGetOrdersRequest(): GetOrdersRequest {
  return { orderId: "" };
}

export const GetOrdersRequest: MessageFns<GetOrdersRequest> = {
  encode(message: GetOrdersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrdersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrdersRequest {
    return { orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "" };
  },

  toJSON(message: GetOrdersRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrdersRequest>, I>>(base?: I): GetOrdersRequest {
    return GetOrdersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOrdersRequest>, I>>(object: I): GetOrdersRequest {
    const message = createBaseGetOrdersRequest();
    message.orderId = object.orderId ?? "";
    return message;
  },
};

function createBaseGetOrdersResponse(): GetOrdersResponse {
  return { detail: undefined };
}

export const GetOrdersResponse: MessageFns<GetOrdersResponse> = {
  encode(message: GetOrdersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.detail !== undefined) {
      Order.encode(message.detail, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrdersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.detail = Order.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrdersResponse {
    return { detail: isSet(object.detail) ? Order.fromJSON(object.detail) : undefined };
  },

  toJSON(message: GetOrdersResponse): unknown {
    const obj: any = {};
    if (message.detail !== undefined) {
      obj.detail = Order.toJSON(message.detail);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrdersResponse>, I>>(base?: I): GetOrdersResponse {
    return GetOrdersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOrdersResponse>, I>>(object: I): GetOrdersResponse {
    const message = createBaseGetOrdersResponse();
    message.detail = (object.detail !== undefined && object.detail !== null)
      ? Order.fromPartial(object.detail)
      : undefined;
    return message;
  },
};

function createBaseUpdateOrderPaymentRequest(): UpdateOrderPaymentRequest {
  return { orderId: "", paymentId: "", paymentStatus: 0 };
}

export const UpdateOrderPaymentRequest: MessageFns<UpdateOrderPaymentRequest> = {
  encode(message: UpdateOrderPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.paymentId !== "") {
      writer.uint32(18).string(message.paymentId);
    }
    if (message.paymentStatus !== 0) {
      writer.uint32(24).int32(message.paymentStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateOrderPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOrderPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.paymentStatus = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateOrderPaymentRequest {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      paymentId: isSet(object.paymentId) ? globalThis.String(object.paymentId) : "",
      paymentStatus: isSet(object.paymentStatus) ? paymentStatusFromJSON(object.paymentStatus) : 0,
    };
  },

  toJSON(message: UpdateOrderPaymentRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    if (message.paymentStatus !== 0) {
      obj.paymentStatus = paymentStatusToJSON(message.paymentStatus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateOrderPaymentRequest>, I>>(base?: I): UpdateOrderPaymentRequest {
    return UpdateOrderPaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateOrderPaymentRequest>, I>>(object: I): UpdateOrderPaymentRequest {
    const message = createBaseUpdateOrderPaymentRequest();
    message.orderId = object.orderId ?? "";
    message.paymentId = object.paymentId ?? "";
    message.paymentStatus = object.paymentStatus ?? 0;
    return message;
  },
};

function createBaseUpdateOrderPaymentResponse(): UpdateOrderPaymentResponse {
  return {};
}

export const UpdateOrderPaymentResponse: MessageFns<UpdateOrderPaymentResponse> = {
  encode(_: UpdateOrderPaymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateOrderPaymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOrderPaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpdateOrderPaymentResponse {
    return {};
  },

  toJSON(_: UpdateOrderPaymentResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateOrderPaymentResponse>, I>>(base?: I): UpdateOrderPaymentResponse {
    return UpdateOrderPaymentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateOrderPaymentResponse>, I>>(_: I): UpdateOrderPaymentResponse {
    const message = createBaseUpdateOrderPaymentResponse();
    return message;
  },
};

function createBaseCancelOrderRequest(): CancelOrderRequest {
  return { orderId: "" };
}

export const CancelOrderRequest: MessageFns<CancelOrderRequest> = {
  encode(message: CancelOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelOrderRequest {
    return { orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "" };
  },

  toJSON(message: CancelOrderRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelOrderRequest>, I>>(base?: I): CancelOrderRequest {
    return CancelOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelOrderRequest>, I>>(object: I): CancelOrderRequest {
    const message = createBaseCancelOrderRequest();
    message.orderId = object.orderId ?? "";
    return message;
  },
};

function createBaseCancelOrderResponse(): CancelOrderResponse {
  return {};
}

export const CancelOrderResponse: MessageFns<CancelOrderResponse> = {
  encode(_: CancelOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CancelOrderResponse {
    return {};
  },

  toJSON(_: CancelOrderResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelOrderResponse>, I>>(base?: I): CancelOrderResponse {
    return CancelOrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelOrderResponse>, I>>(_: I): CancelOrderResponse {
    const message = createBaseCancelOrderResponse();
    return message;
  },
};

function createBaseOrderInternal(): OrderInternal {
  return {
    meta: undefined,
    buyerId: "",
    items: [],
    shippingAddress: "",
    billingAddress: "",
    sameAsShippingAddress: false,
    totalPrice: 0,
    orderStatus: 0,
    payment: [],
    deliveredAt: undefined,
  };
}

export const OrderInternal: MessageFns<OrderInternal> = {
  encode(message: OrderInternal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.meta !== undefined) {
      Meta.encode(message.meta, writer.uint32(10).fork()).join();
    }
    if (message.buyerId !== "") {
      writer.uint32(18).string(message.buyerId);
    }
    for (const v of message.items) {
      OrderItem.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.shippingAddress !== "") {
      writer.uint32(34).string(message.shippingAddress);
    }
    if (message.billingAddress !== "") {
      writer.uint32(42).string(message.billingAddress);
    }
    if (message.sameAsShippingAddress !== false) {
      writer.uint32(48).bool(message.sameAsShippingAddress);
    }
    if (message.totalPrice !== 0) {
      writer.uint32(56).int32(message.totalPrice);
    }
    if (message.orderStatus !== 0) {
      writer.uint32(64).int32(message.orderStatus);
    }
    for (const v of message.payment) {
      Payment.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.deliveredAt !== undefined) {
      Timestamp.encode(toTimestamp(message.deliveredAt), writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderInternal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderInternal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.meta = Meta.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.buyerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.items.push(OrderItem.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.shippingAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.billingAddress = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.sameAsShippingAddress = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.totalPrice = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.orderStatus = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.payment.push(Payment.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.deliveredAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderInternal {
    return {
      meta: isSet(object.meta) ? Meta.fromJSON(object.meta) : undefined,
      buyerId: isSet(object.buyerId) ? globalThis.String(object.buyerId) : "",
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => OrderItem.fromJSON(e)) : [],
      shippingAddress: isSet(object.shippingAddress) ? globalThis.String(object.shippingAddress) : "",
      billingAddress: isSet(object.billingAddress) ? globalThis.String(object.billingAddress) : "",
      sameAsShippingAddress: isSet(object.sameAsShippingAddress)
        ? globalThis.Boolean(object.sameAsShippingAddress)
        : false,
      totalPrice: isSet(object.totalPrice) ? globalThis.Number(object.totalPrice) : 0,
      orderStatus: isSet(object.orderStatus) ? orderStatusFromJSON(object.orderStatus) : 0,
      payment: globalThis.Array.isArray(object?.payment) ? object.payment.map((e: any) => Payment.fromJSON(e)) : [],
      deliveredAt: isSet(object.deliveredAt) ? fromJsonTimestamp(object.deliveredAt) : undefined,
    };
  },

  toJSON(message: OrderInternal): unknown {
    const obj: any = {};
    if (message.meta !== undefined) {
      obj.meta = Meta.toJSON(message.meta);
    }
    if (message.buyerId !== "") {
      obj.buyerId = message.buyerId;
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => OrderItem.toJSON(e));
    }
    if (message.shippingAddress !== "") {
      obj.shippingAddress = message.shippingAddress;
    }
    if (message.billingAddress !== "") {
      obj.billingAddress = message.billingAddress;
    }
    if (message.sameAsShippingAddress !== false) {
      obj.sameAsShippingAddress = message.sameAsShippingAddress;
    }
    if (message.totalPrice !== 0) {
      obj.totalPrice = Math.round(message.totalPrice);
    }
    if (message.orderStatus !== 0) {
      obj.orderStatus = orderStatusToJSON(message.orderStatus);
    }
    if (message.payment?.length) {
      obj.payment = message.payment.map((e) => Payment.toJSON(e));
    }
    if (message.deliveredAt !== undefined) {
      obj.deliveredAt = message.deliveredAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderInternal>, I>>(base?: I): OrderInternal {
    return OrderInternal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderInternal>, I>>(object: I): OrderInternal {
    const message = createBaseOrderInternal();
    message.meta = (object.meta !== undefined && object.meta !== null) ? Meta.fromPartial(object.meta) : undefined;
    message.buyerId = object.buyerId ?? "";
    message.items = object.items?.map((e) => OrderItem.fromPartial(e)) || [];
    message.shippingAddress = object.shippingAddress ?? "";
    message.billingAddress = object.billingAddress ?? "";
    message.sameAsShippingAddress = object.sameAsShippingAddress ?? false;
    message.totalPrice = object.totalPrice ?? 0;
    message.orderStatus = object.orderStatus ?? 0;
    message.payment = object.payment?.map((e) => Payment.fromPartial(e)) || [];
    message.deliveredAt = object.deliveredAt ?? undefined;
    return message;
  },
};

export interface OrderService {
  CreateOrder(request: CreateOrderRequest): Promise<CreateOrderResponse>;
  ListBuyerOrders(request: ListOrdersRequest): Promise<ListOrdersResponse>;
  ListSellerOrders(request: ListOrdersRequest): Promise<ListOrdersResponse>;
  GetBuyerOrders(request: GetOrdersRequest): Promise<GetOrdersResponse>;
  GetSellerOrders(request: GetOrdersRequest): Promise<GetOrdersResponse>;
  UpdateOrderPayment(request: UpdateOrderPaymentRequest): Promise<UpdateOrderPaymentResponse>;
  CancelOrder(request: CancelOrderRequest): Promise<CancelOrderResponse>;
}

export const OrderServiceServiceName = "services.ecommerce.v1.orders.OrderService";
export class OrderServiceClientImpl implements OrderService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || OrderServiceServiceName;
    this.rpc = rpc;
    this.CreateOrder = this.CreateOrder.bind(this);
    this.ListBuyerOrders = this.ListBuyerOrders.bind(this);
    this.ListSellerOrders = this.ListSellerOrders.bind(this);
    this.GetBuyerOrders = this.GetBuyerOrders.bind(this);
    this.GetSellerOrders = this.GetSellerOrders.bind(this);
    this.UpdateOrderPayment = this.UpdateOrderPayment.bind(this);
    this.CancelOrder = this.CancelOrder.bind(this);
  }
  CreateOrder(request: CreateOrderRequest): Promise<CreateOrderResponse> {
    const data = CreateOrderRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOrder", data);
    return promise.then((data) => CreateOrderResponse.decode(new BinaryReader(data)));
  }

  ListBuyerOrders(request: ListOrdersRequest): Promise<ListOrdersResponse> {
    const data = ListOrdersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListBuyerOrders", data);
    return promise.then((data) => ListOrdersResponse.decode(new BinaryReader(data)));
  }

  ListSellerOrders(request: ListOrdersRequest): Promise<ListOrdersResponse> {
    const data = ListOrdersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListSellerOrders", data);
    return promise.then((data) => ListOrdersResponse.decode(new BinaryReader(data)));
  }

  GetBuyerOrders(request: GetOrdersRequest): Promise<GetOrdersResponse> {
    const data = GetOrdersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetBuyerOrders", data);
    return promise.then((data) => GetOrdersResponse.decode(new BinaryReader(data)));
  }

  GetSellerOrders(request: GetOrdersRequest): Promise<GetOrdersResponse> {
    const data = GetOrdersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetSellerOrders", data);
    return promise.then((data) => GetOrdersResponse.decode(new BinaryReader(data)));
  }

  UpdateOrderPayment(request: UpdateOrderPaymentRequest): Promise<UpdateOrderPaymentResponse> {
    const data = UpdateOrderPaymentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateOrderPayment", data);
    return promise.then((data) => UpdateOrderPaymentResponse.decode(new BinaryReader(data)));
  }

  CancelOrder(request: CancelOrderRequest): Promise<CancelOrderResponse> {
    const data = CancelOrderRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CancelOrder", data);
    return promise.then((data) => CancelOrderResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
