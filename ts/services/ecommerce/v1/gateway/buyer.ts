// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.5.1
//   protoc               v3.12.4
// source: services/ecommerce/v1/gateway/buyer.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { PageOptions } from "../../../../common/messages";
import { Order, OrderItem, OrderStatus, orderStatusFromJSON, orderStatusToJSON } from "../orders";
import {
  PaymentMethod,
  paymentMethodFromJSON,
  paymentMethodToJSON,
  PaymentStatus,
  paymentStatusFromJSON,
  paymentStatusToJSON,
} from "../payments";
import { Product, ProductSortBy, productSortByFromJSON, productSortByToJSON } from "../products";

export const protobufPackage = "services.ecommerce.v1.gateway";

export interface ListProductsRequest {
  pageOptions?: PageOptions | undefined;
  sortBy: ProductSortBy;
  searchTerm: string;
  categories: string[];
}

export interface ListProductsResponse {
  products: Product[];
  total: number;
}

export interface GetProductRequest {
  productId: string;
}

export interface GetProductResponse {
  detail?: Product | undefined;
}

export interface AddToCartRequest {
  productId: string;
  quantity: number;
}

export interface AddToCartResponse {
  totalCartProducts: number;
}

export interface RemoveFromCartRequest {
  productId: string;
  quantity: number;
}

export interface RemoveFromCartResponse {
  totalCartProducts: number;
}

export interface ClearCartRequest {
}

export interface ClearCartResponse {
}

export interface ViewCartRequest {
}

export interface ViewCartResponse {
  products: Product[];
  totalCartProducts: number;
}

export interface CreateOrderRequest {
  /** Cart ID for orders with multiple items */
  cartId?:
    | string
    | undefined;
  /** Single item purchase (instant buy) */
  item?:
    | OrderItem
    | undefined;
  /** Address for shipping */
  shippingAddress: string;
  /** Address for billing (if different) */
  billingAddress: string;
  sameAsShippingAddress: boolean;
  /** Payment method - credit card, upi, etc. */
  paymentMethod: PaymentMethod;
}

export interface CreateOrderResponse {
  orderId: string;
  status: OrderStatus;
  /** Payment status - initiated, pending, fulfilled, failed */
  paymentStatus: PaymentStatus;
}

export interface ListOrdersRequest {
  pageOptions?: PageOptions | undefined;
  searchTerm: string;
}

export interface ListOrdersResponse {
  /** List of orders */
  orders: Order[];
  /** Total number of orders matching the criteria */
  totalOrders: number;
}

export interface GetOrdersRequest {
  orderId: string;
}

export interface GetOrdersResponse {
  detail?: Order | undefined;
}

export interface CancelOrderRequest {
  orderId: string;
}

export interface CancelOrderResponse {
}

function createBaseListProductsRequest(): ListProductsRequest {
  return { pageOptions: undefined, sortBy: 0, searchTerm: "", categories: [] };
}

export const ListProductsRequest: MessageFns<ListProductsRequest> = {
  encode(message: ListProductsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageOptions !== undefined) {
      PageOptions.encode(message.pageOptions, writer.uint32(10).fork()).join();
    }
    if (message.sortBy !== 0) {
      writer.uint32(16).int32(message.sortBy);
    }
    if (message.searchTerm !== "") {
      writer.uint32(26).string(message.searchTerm);
    }
    for (const v of message.categories) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProductsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProductsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pageOptions = PageOptions.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sortBy = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.searchTerm = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.categories.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProductsRequest {
    return {
      pageOptions: isSet(object.pageOptions) ? PageOptions.fromJSON(object.pageOptions) : undefined,
      sortBy: isSet(object.sortBy) ? productSortByFromJSON(object.sortBy) : 0,
      searchTerm: isSet(object.searchTerm) ? globalThis.String(object.searchTerm) : "",
      categories: globalThis.Array.isArray(object?.categories)
        ? object.categories.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListProductsRequest): unknown {
    const obj: any = {};
    if (message.pageOptions !== undefined) {
      obj.pageOptions = PageOptions.toJSON(message.pageOptions);
    }
    if (message.sortBy !== 0) {
      obj.sortBy = productSortByToJSON(message.sortBy);
    }
    if (message.searchTerm !== "") {
      obj.searchTerm = message.searchTerm;
    }
    if (message.categories?.length) {
      obj.categories = message.categories;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListProductsRequest>, I>>(base?: I): ListProductsRequest {
    return ListProductsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListProductsRequest>, I>>(object: I): ListProductsRequest {
    const message = createBaseListProductsRequest();
    message.pageOptions = (object.pageOptions !== undefined && object.pageOptions !== null)
      ? PageOptions.fromPartial(object.pageOptions)
      : undefined;
    message.sortBy = object.sortBy ?? 0;
    message.searchTerm = object.searchTerm ?? "";
    message.categories = object.categories?.map((e) => e) || [];
    return message;
  },
};

function createBaseListProductsResponse(): ListProductsResponse {
  return { products: [], total: 0 };
}

export const ListProductsResponse: MessageFns<ListProductsResponse> = {
  encode(message: ListProductsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.products) {
      Product.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProductsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProductsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.products.push(Product.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProductsResponse {
    return {
      products: globalThis.Array.isArray(object?.products) ? object.products.map((e: any) => Product.fromJSON(e)) : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: ListProductsResponse): unknown {
    const obj: any = {};
    if (message.products?.length) {
      obj.products = message.products.map((e) => Product.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListProductsResponse>, I>>(base?: I): ListProductsResponse {
    return ListProductsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListProductsResponse>, I>>(object: I): ListProductsResponse {
    const message = createBaseListProductsResponse();
    message.products = object.products?.map((e) => Product.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    return message;
  },
};

function createBaseGetProductRequest(): GetProductRequest {
  return { productId: "" };
}

export const GetProductRequest: MessageFns<GetProductRequest> = {
  encode(message: GetProductRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProductRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProductRequest {
    return { productId: isSet(object.productId) ? globalThis.String(object.productId) : "" };
  },

  toJSON(message: GetProductRequest): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProductRequest>, I>>(base?: I): GetProductRequest {
    return GetProductRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProductRequest>, I>>(object: I): GetProductRequest {
    const message = createBaseGetProductRequest();
    message.productId = object.productId ?? "";
    return message;
  },
};

function createBaseGetProductResponse(): GetProductResponse {
  return { detail: undefined };
}

export const GetProductResponse: MessageFns<GetProductResponse> = {
  encode(message: GetProductResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.detail !== undefined) {
      Product.encode(message.detail, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProductResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.detail = Product.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProductResponse {
    return { detail: isSet(object.detail) ? Product.fromJSON(object.detail) : undefined };
  },

  toJSON(message: GetProductResponse): unknown {
    const obj: any = {};
    if (message.detail !== undefined) {
      obj.detail = Product.toJSON(message.detail);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProductResponse>, I>>(base?: I): GetProductResponse {
    return GetProductResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProductResponse>, I>>(object: I): GetProductResponse {
    const message = createBaseGetProductResponse();
    message.detail = (object.detail !== undefined && object.detail !== null)
      ? Product.fromPartial(object.detail)
      : undefined;
    return message;
  },
};

function createBaseAddToCartRequest(): AddToCartRequest {
  return { productId: "", quantity: 0 };
}

export const AddToCartRequest: MessageFns<AddToCartRequest> = {
  encode(message: AddToCartRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    if (message.quantity !== 0) {
      writer.uint32(16).int32(message.quantity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddToCartRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddToCartRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddToCartRequest {
    return {
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
    };
  },

  toJSON(message: AddToCartRequest): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddToCartRequest>, I>>(base?: I): AddToCartRequest {
    return AddToCartRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddToCartRequest>, I>>(object: I): AddToCartRequest {
    const message = createBaseAddToCartRequest();
    message.productId = object.productId ?? "";
    message.quantity = object.quantity ?? 0;
    return message;
  },
};

function createBaseAddToCartResponse(): AddToCartResponse {
  return { totalCartProducts: 0 };
}

export const AddToCartResponse: MessageFns<AddToCartResponse> = {
  encode(message: AddToCartResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalCartProducts !== 0) {
      writer.uint32(8).int32(message.totalCartProducts);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddToCartResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddToCartResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalCartProducts = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddToCartResponse {
    return { totalCartProducts: isSet(object.totalCartProducts) ? globalThis.Number(object.totalCartProducts) : 0 };
  },

  toJSON(message: AddToCartResponse): unknown {
    const obj: any = {};
    if (message.totalCartProducts !== 0) {
      obj.totalCartProducts = Math.round(message.totalCartProducts);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddToCartResponse>, I>>(base?: I): AddToCartResponse {
    return AddToCartResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddToCartResponse>, I>>(object: I): AddToCartResponse {
    const message = createBaseAddToCartResponse();
    message.totalCartProducts = object.totalCartProducts ?? 0;
    return message;
  },
};

function createBaseRemoveFromCartRequest(): RemoveFromCartRequest {
  return { productId: "", quantity: 0 };
}

export const RemoveFromCartRequest: MessageFns<RemoveFromCartRequest> = {
  encode(message: RemoveFromCartRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    if (message.quantity !== 0) {
      writer.uint32(16).int32(message.quantity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveFromCartRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveFromCartRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveFromCartRequest {
    return {
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
    };
  },

  toJSON(message: RemoveFromCartRequest): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveFromCartRequest>, I>>(base?: I): RemoveFromCartRequest {
    return RemoveFromCartRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveFromCartRequest>, I>>(object: I): RemoveFromCartRequest {
    const message = createBaseRemoveFromCartRequest();
    message.productId = object.productId ?? "";
    message.quantity = object.quantity ?? 0;
    return message;
  },
};

function createBaseRemoveFromCartResponse(): RemoveFromCartResponse {
  return { totalCartProducts: 0 };
}

export const RemoveFromCartResponse: MessageFns<RemoveFromCartResponse> = {
  encode(message: RemoveFromCartResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalCartProducts !== 0) {
      writer.uint32(8).int32(message.totalCartProducts);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveFromCartResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveFromCartResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalCartProducts = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveFromCartResponse {
    return { totalCartProducts: isSet(object.totalCartProducts) ? globalThis.Number(object.totalCartProducts) : 0 };
  },

  toJSON(message: RemoveFromCartResponse): unknown {
    const obj: any = {};
    if (message.totalCartProducts !== 0) {
      obj.totalCartProducts = Math.round(message.totalCartProducts);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveFromCartResponse>, I>>(base?: I): RemoveFromCartResponse {
    return RemoveFromCartResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveFromCartResponse>, I>>(object: I): RemoveFromCartResponse {
    const message = createBaseRemoveFromCartResponse();
    message.totalCartProducts = object.totalCartProducts ?? 0;
    return message;
  },
};

function createBaseClearCartRequest(): ClearCartRequest {
  return {};
}

export const ClearCartRequest: MessageFns<ClearCartRequest> = {
  encode(_: ClearCartRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClearCartRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClearCartRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ClearCartRequest {
    return {};
  },

  toJSON(_: ClearCartRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ClearCartRequest>, I>>(base?: I): ClearCartRequest {
    return ClearCartRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClearCartRequest>, I>>(_: I): ClearCartRequest {
    const message = createBaseClearCartRequest();
    return message;
  },
};

function createBaseClearCartResponse(): ClearCartResponse {
  return {};
}

export const ClearCartResponse: MessageFns<ClearCartResponse> = {
  encode(_: ClearCartResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClearCartResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClearCartResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ClearCartResponse {
    return {};
  },

  toJSON(_: ClearCartResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ClearCartResponse>, I>>(base?: I): ClearCartResponse {
    return ClearCartResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClearCartResponse>, I>>(_: I): ClearCartResponse {
    const message = createBaseClearCartResponse();
    return message;
  },
};

function createBaseViewCartRequest(): ViewCartRequest {
  return {};
}

export const ViewCartRequest: MessageFns<ViewCartRequest> = {
  encode(_: ViewCartRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ViewCartRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseViewCartRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ViewCartRequest {
    return {};
  },

  toJSON(_: ViewCartRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ViewCartRequest>, I>>(base?: I): ViewCartRequest {
    return ViewCartRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ViewCartRequest>, I>>(_: I): ViewCartRequest {
    const message = createBaseViewCartRequest();
    return message;
  },
};

function createBaseViewCartResponse(): ViewCartResponse {
  return { products: [], totalCartProducts: 0 };
}

export const ViewCartResponse: MessageFns<ViewCartResponse> = {
  encode(message: ViewCartResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.products) {
      Product.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCartProducts !== 0) {
      writer.uint32(16).int32(message.totalCartProducts);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ViewCartResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseViewCartResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.products.push(Product.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCartProducts = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ViewCartResponse {
    return {
      products: globalThis.Array.isArray(object?.products) ? object.products.map((e: any) => Product.fromJSON(e)) : [],
      totalCartProducts: isSet(object.totalCartProducts) ? globalThis.Number(object.totalCartProducts) : 0,
    };
  },

  toJSON(message: ViewCartResponse): unknown {
    const obj: any = {};
    if (message.products?.length) {
      obj.products = message.products.map((e) => Product.toJSON(e));
    }
    if (message.totalCartProducts !== 0) {
      obj.totalCartProducts = Math.round(message.totalCartProducts);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ViewCartResponse>, I>>(base?: I): ViewCartResponse {
    return ViewCartResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ViewCartResponse>, I>>(object: I): ViewCartResponse {
    const message = createBaseViewCartResponse();
    message.products = object.products?.map((e) => Product.fromPartial(e)) || [];
    message.totalCartProducts = object.totalCartProducts ?? 0;
    return message;
  },
};

function createBaseCreateOrderRequest(): CreateOrderRequest {
  return {
    cartId: undefined,
    item: undefined,
    shippingAddress: "",
    billingAddress: "",
    sameAsShippingAddress: false,
    paymentMethod: 0,
  };
}

export const CreateOrderRequest: MessageFns<CreateOrderRequest> = {
  encode(message: CreateOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cartId !== undefined) {
      writer.uint32(10).string(message.cartId);
    }
    if (message.item !== undefined) {
      OrderItem.encode(message.item, writer.uint32(18).fork()).join();
    }
    if (message.shippingAddress !== "") {
      writer.uint32(26).string(message.shippingAddress);
    }
    if (message.billingAddress !== "") {
      writer.uint32(34).string(message.billingAddress);
    }
    if (message.sameAsShippingAddress !== false) {
      writer.uint32(40).bool(message.sameAsShippingAddress);
    }
    if (message.paymentMethod !== 0) {
      writer.uint32(48).int32(message.paymentMethod);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cartId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.item = OrderItem.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.shippingAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.billingAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.sameAsShippingAddress = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.paymentMethod = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOrderRequest {
    return {
      cartId: isSet(object.cartId) ? globalThis.String(object.cartId) : undefined,
      item: isSet(object.item) ? OrderItem.fromJSON(object.item) : undefined,
      shippingAddress: isSet(object.shippingAddress) ? globalThis.String(object.shippingAddress) : "",
      billingAddress: isSet(object.billingAddress) ? globalThis.String(object.billingAddress) : "",
      sameAsShippingAddress: isSet(object.sameAsShippingAddress)
        ? globalThis.Boolean(object.sameAsShippingAddress)
        : false,
      paymentMethod: isSet(object.paymentMethod) ? paymentMethodFromJSON(object.paymentMethod) : 0,
    };
  },

  toJSON(message: CreateOrderRequest): unknown {
    const obj: any = {};
    if (message.cartId !== undefined) {
      obj.cartId = message.cartId;
    }
    if (message.item !== undefined) {
      obj.item = OrderItem.toJSON(message.item);
    }
    if (message.shippingAddress !== "") {
      obj.shippingAddress = message.shippingAddress;
    }
    if (message.billingAddress !== "") {
      obj.billingAddress = message.billingAddress;
    }
    if (message.sameAsShippingAddress !== false) {
      obj.sameAsShippingAddress = message.sameAsShippingAddress;
    }
    if (message.paymentMethod !== 0) {
      obj.paymentMethod = paymentMethodToJSON(message.paymentMethod);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateOrderRequest>, I>>(base?: I): CreateOrderRequest {
    return CreateOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateOrderRequest>, I>>(object: I): CreateOrderRequest {
    const message = createBaseCreateOrderRequest();
    message.cartId = object.cartId ?? undefined;
    message.item = (object.item !== undefined && object.item !== null) ? OrderItem.fromPartial(object.item) : undefined;
    message.shippingAddress = object.shippingAddress ?? "";
    message.billingAddress = object.billingAddress ?? "";
    message.sameAsShippingAddress = object.sameAsShippingAddress ?? false;
    message.paymentMethod = object.paymentMethod ?? 0;
    return message;
  },
};

function createBaseCreateOrderResponse(): CreateOrderResponse {
  return { orderId: "", status: 0, paymentStatus: 0 };
}

export const CreateOrderResponse: MessageFns<CreateOrderResponse> = {
  encode(message: CreateOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.paymentStatus !== 0) {
      writer.uint32(24).int32(message.paymentStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.paymentStatus = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOrderResponse {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      status: isSet(object.status) ? orderStatusFromJSON(object.status) : 0,
      paymentStatus: isSet(object.paymentStatus) ? paymentStatusFromJSON(object.paymentStatus) : 0,
    };
  },

  toJSON(message: CreateOrderResponse): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.status !== 0) {
      obj.status = orderStatusToJSON(message.status);
    }
    if (message.paymentStatus !== 0) {
      obj.paymentStatus = paymentStatusToJSON(message.paymentStatus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateOrderResponse>, I>>(base?: I): CreateOrderResponse {
    return CreateOrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateOrderResponse>, I>>(object: I): CreateOrderResponse {
    const message = createBaseCreateOrderResponse();
    message.orderId = object.orderId ?? "";
    message.status = object.status ?? 0;
    message.paymentStatus = object.paymentStatus ?? 0;
    return message;
  },
};

function createBaseListOrdersRequest(): ListOrdersRequest {
  return { pageOptions: undefined, searchTerm: "" };
}

export const ListOrdersRequest: MessageFns<ListOrdersRequest> = {
  encode(message: ListOrdersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageOptions !== undefined) {
      PageOptions.encode(message.pageOptions, writer.uint32(10).fork()).join();
    }
    if (message.searchTerm !== "") {
      writer.uint32(18).string(message.searchTerm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOrdersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pageOptions = PageOptions.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.searchTerm = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOrdersRequest {
    return {
      pageOptions: isSet(object.pageOptions) ? PageOptions.fromJSON(object.pageOptions) : undefined,
      searchTerm: isSet(object.searchTerm) ? globalThis.String(object.searchTerm) : "",
    };
  },

  toJSON(message: ListOrdersRequest): unknown {
    const obj: any = {};
    if (message.pageOptions !== undefined) {
      obj.pageOptions = PageOptions.toJSON(message.pageOptions);
    }
    if (message.searchTerm !== "") {
      obj.searchTerm = message.searchTerm;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListOrdersRequest>, I>>(base?: I): ListOrdersRequest {
    return ListOrdersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListOrdersRequest>, I>>(object: I): ListOrdersRequest {
    const message = createBaseListOrdersRequest();
    message.pageOptions = (object.pageOptions !== undefined && object.pageOptions !== null)
      ? PageOptions.fromPartial(object.pageOptions)
      : undefined;
    message.searchTerm = object.searchTerm ?? "";
    return message;
  },
};

function createBaseListOrdersResponse(): ListOrdersResponse {
  return { orders: [], totalOrders: 0 };
}

export const ListOrdersResponse: MessageFns<ListOrdersResponse> = {
  encode(message: ListOrdersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.orders) {
      Order.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalOrders !== 0) {
      writer.uint32(16).int32(message.totalOrders);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOrdersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orders.push(Order.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalOrders = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOrdersResponse {
    return {
      orders: globalThis.Array.isArray(object?.orders) ? object.orders.map((e: any) => Order.fromJSON(e)) : [],
      totalOrders: isSet(object.totalOrders) ? globalThis.Number(object.totalOrders) : 0,
    };
  },

  toJSON(message: ListOrdersResponse): unknown {
    const obj: any = {};
    if (message.orders?.length) {
      obj.orders = message.orders.map((e) => Order.toJSON(e));
    }
    if (message.totalOrders !== 0) {
      obj.totalOrders = Math.round(message.totalOrders);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListOrdersResponse>, I>>(base?: I): ListOrdersResponse {
    return ListOrdersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListOrdersResponse>, I>>(object: I): ListOrdersResponse {
    const message = createBaseListOrdersResponse();
    message.orders = object.orders?.map((e) => Order.fromPartial(e)) || [];
    message.totalOrders = object.totalOrders ?? 0;
    return message;
  },
};

function createBaseGetOrdersRequest(): GetOrdersRequest {
  return { orderId: "" };
}

export const GetOrdersRequest: MessageFns<GetOrdersRequest> = {
  encode(message: GetOrdersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrdersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrdersRequest {
    return { orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "" };
  },

  toJSON(message: GetOrdersRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrdersRequest>, I>>(base?: I): GetOrdersRequest {
    return GetOrdersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOrdersRequest>, I>>(object: I): GetOrdersRequest {
    const message = createBaseGetOrdersRequest();
    message.orderId = object.orderId ?? "";
    return message;
  },
};

function createBaseGetOrdersResponse(): GetOrdersResponse {
  return { detail: undefined };
}

export const GetOrdersResponse: MessageFns<GetOrdersResponse> = {
  encode(message: GetOrdersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.detail !== undefined) {
      Order.encode(message.detail, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrdersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.detail = Order.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrdersResponse {
    return { detail: isSet(object.detail) ? Order.fromJSON(object.detail) : undefined };
  },

  toJSON(message: GetOrdersResponse): unknown {
    const obj: any = {};
    if (message.detail !== undefined) {
      obj.detail = Order.toJSON(message.detail);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrdersResponse>, I>>(base?: I): GetOrdersResponse {
    return GetOrdersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOrdersResponse>, I>>(object: I): GetOrdersResponse {
    const message = createBaseGetOrdersResponse();
    message.detail = (object.detail !== undefined && object.detail !== null)
      ? Order.fromPartial(object.detail)
      : undefined;
    return message;
  },
};

function createBaseCancelOrderRequest(): CancelOrderRequest {
  return { orderId: "" };
}

export const CancelOrderRequest: MessageFns<CancelOrderRequest> = {
  encode(message: CancelOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelOrderRequest {
    return { orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "" };
  },

  toJSON(message: CancelOrderRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelOrderRequest>, I>>(base?: I): CancelOrderRequest {
    return CancelOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelOrderRequest>, I>>(object: I): CancelOrderRequest {
    const message = createBaseCancelOrderRequest();
    message.orderId = object.orderId ?? "";
    return message;
  },
};

function createBaseCancelOrderResponse(): CancelOrderResponse {
  return {};
}

export const CancelOrderResponse: MessageFns<CancelOrderResponse> = {
  encode(_: CancelOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CancelOrderResponse {
    return {};
  },

  toJSON(_: CancelOrderResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelOrderResponse>, I>>(base?: I): CancelOrderResponse {
    return CancelOrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelOrderResponse>, I>>(_: I): CancelOrderResponse {
    const message = createBaseCancelOrderResponse();
    return message;
  },
};

export interface BuyerGateway {
  /** Product-related APIs */
  ListProducts(request: ListProductsRequest): Promise<ListProductsResponse>;
  GetProduct(request: GetProductRequest): Promise<GetProductResponse>;
  /** Cart-related APIs */
  AddToCart(request: AddToCartRequest): Promise<AddToCartResponse>;
  RemoveFromCart(request: RemoveFromCartRequest): Promise<RemoveFromCartResponse>;
  ClearCart(request: ClearCartRequest): Promise<ClearCartResponse>;
  ViewCart(request: ViewCartRequest): Promise<ViewCartResponse>;
  /** Order-related APIs */
  CreateOrder(request: CreateOrderRequest): Promise<CreateOrderResponse>;
  ListOrders(request: ListOrdersRequest): Promise<ListOrdersResponse>;
  GetOrders(request: GetOrdersRequest): Promise<GetOrdersResponse>;
  CancelOrder(request: CancelOrderRequest): Promise<CancelOrderResponse>;
}

export const BuyerGatewayServiceName = "services.ecommerce.v1.gateway.BuyerGateway";
export class BuyerGatewayClientImpl implements BuyerGateway {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || BuyerGatewayServiceName;
    this.rpc = rpc;
    this.ListProducts = this.ListProducts.bind(this);
    this.GetProduct = this.GetProduct.bind(this);
    this.AddToCart = this.AddToCart.bind(this);
    this.RemoveFromCart = this.RemoveFromCart.bind(this);
    this.ClearCart = this.ClearCart.bind(this);
    this.ViewCart = this.ViewCart.bind(this);
    this.CreateOrder = this.CreateOrder.bind(this);
    this.ListOrders = this.ListOrders.bind(this);
    this.GetOrders = this.GetOrders.bind(this);
    this.CancelOrder = this.CancelOrder.bind(this);
  }
  ListProducts(request: ListProductsRequest): Promise<ListProductsResponse> {
    const data = ListProductsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListProducts", data);
    return promise.then((data) => ListProductsResponse.decode(new BinaryReader(data)));
  }

  GetProduct(request: GetProductRequest): Promise<GetProductResponse> {
    const data = GetProductRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetProduct", data);
    return promise.then((data) => GetProductResponse.decode(new BinaryReader(data)));
  }

  AddToCart(request: AddToCartRequest): Promise<AddToCartResponse> {
    const data = AddToCartRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddToCart", data);
    return promise.then((data) => AddToCartResponse.decode(new BinaryReader(data)));
  }

  RemoveFromCart(request: RemoveFromCartRequest): Promise<RemoveFromCartResponse> {
    const data = RemoveFromCartRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RemoveFromCart", data);
    return promise.then((data) => RemoveFromCartResponse.decode(new BinaryReader(data)));
  }

  ClearCart(request: ClearCartRequest): Promise<ClearCartResponse> {
    const data = ClearCartRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ClearCart", data);
    return promise.then((data) => ClearCartResponse.decode(new BinaryReader(data)));
  }

  ViewCart(request: ViewCartRequest): Promise<ViewCartResponse> {
    const data = ViewCartRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ViewCart", data);
    return promise.then((data) => ViewCartResponse.decode(new BinaryReader(data)));
  }

  CreateOrder(request: CreateOrderRequest): Promise<CreateOrderResponse> {
    const data = CreateOrderRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOrder", data);
    return promise.then((data) => CreateOrderResponse.decode(new BinaryReader(data)));
  }

  ListOrders(request: ListOrdersRequest): Promise<ListOrdersResponse> {
    const data = ListOrdersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListOrders", data);
    return promise.then((data) => ListOrdersResponse.decode(new BinaryReader(data)));
  }

  GetOrders(request: GetOrdersRequest): Promise<GetOrdersResponse> {
    const data = GetOrdersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetOrders", data);
    return promise.then((data) => GetOrdersResponse.decode(new BinaryReader(data)));
  }

  CancelOrder(request: CancelOrderRequest): Promise<CancelOrderResponse> {
    const data = CancelOrderRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CancelOrder", data);
    return promise.then((data) => CancelOrderResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
